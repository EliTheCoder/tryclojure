goog.provide('app.tutorial');
/**
 * Collection of map steps.
 */
app.tutorial.tutorial = new cljs.core.PersistentVector(null, 18, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Hello string!",new cljs.core.Keyword(null,"content","content",15833224),"> Learn the principle, abide by the principle, and dissolve the principle. - Bruce Lee\n     \n  Let's start with the basic. Clojure offers the most common data types, like integers,\n     boolean and strings. Strings are surrounded by `\"`.\n    \n  Try creating a string saying *hello* to the *world*, as `\"Hello World\"`",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77127_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(clojure.string.lower_case(p1__77127_SHARP_),"hello world");
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Embrace the lists",new cljs.core.Keyword(null,"content","content",15833224),"> Lisp is the greatest single programming language ever designed - Alan Kay\n    \n  Lisp stands for *LISt Processing* and its peculiarity is that code is written in [lists](https://en.wikipedia.org/wiki/S-expression). Clojure is a Lisp dialect so it uses a similar syntax.\n\n  A list is a collection of items as `(1 2 3)`. In Clojure you can\n     create lists using `list` or prepending `'`.\n\n  Create a list of elements for example `(list 1 2 3)` or `'(1 2 3)`.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77128_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__77128_SHARP_,cljs.core.list((1),(2),(3)));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Math is (fun)",new cljs.core.Keyword(null,"content","content",15833224),"In Clojure mathematical operators are like normal functions. \n     As you already know, you have to include them in parenthesis `(...)`.\n  \n  So instead of `4 + 2` you will do `(+ 4 2)`. Try to type a numerical operation with `+-/*`.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77129_SHARP_){
return typeof p1__77129_SHARP_ === 'number';
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Clojure is functional",new cljs.core.Keyword(null,"content","content",15833224),"> Lisp is functional. And the future is looking very functional to me. - Robert C. Martin\n  \n  The first argument of a list needs to be a **function**. The *rest*, \n     are the arguments to that function. In the expression `(not true)`,\n     *not* is the negation function and *true* is the argument. \n     \n  Try to use the function `(my-name)` followed by your name as a \"string\", as `(my-name \"Elia\")`.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77130_SHARP_){
return ((cljs.core.map_QMARK_(p1__77130_SHARP_)) && (((cljs.core.contains_QMARK_(p1__77130_SHARP_,new cljs.core.Keyword(null,"user-name","user-name",1302913545))) && (typeof new cljs.core.Keyword(null,"user-name","user-name",1302913545).cljs$core$IFn$_invoke$arity$1(p1__77130_SHARP_) === 'string'))));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Don't forget the keys",new cljs.core.Keyword(null,"content","content",15833224),"> These days, the problem isn't how to innovate; it's how to get society to adopt the good ideas that already exist. - Douglas Engelbart\n     \n  Hi there, **[[user-name]]**! Nice to meet you.\n    \n  In the REPL you are getting back the evaluation of the expression that you typed.\n    As you can see, `:user-name` is in a special form; it's called a *keyword*.\n    You have to prepend `:` to a word to create one. \n     \n  Use the keyword `:next` to continue.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77131_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__77131_SHARP_,new cljs.core.Keyword(null,"next","next",-117701485));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"A function for everything",new cljs.core.Keyword(null,"content","content",15833224),"Let's tweak our interface!\n     \n  You already know how to invoke functions, how to use keywords and strings.\n     What if I tell you that you can change the prompt?\n\n  You can call functions with keywords parameters, as `(create-dog :name \"Zeus\" :breed \"Beagle\")`\n     \n  Use the function `(set-prompt)` and set a color. It accepts optionally `:color` and `:text` as strings. \n     On click on `(set-prompt :color \"red\")`",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77132_SHARP_){
return cljs.core.contains_QMARK_(p1__77132_SHARP_,new cljs.core.Keyword(null,"prompt-color","prompt-color",1906612381));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Functional practicioner!",new cljs.core.Keyword(null,"content","content",15833224),"Congratulations, you have called a function and changed the state of the application! \n     And the entire command was\u2026 a list!\n                                                                                     \n  Clojure offers multiple functions to work with lists, as `reverse`. It reverse a collection\n     so if you pass a string will use it as a collection of characters.\n     \n  Type `(reverse \"a-long-string\")` to advance at the next step.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77133_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__77133_SHARP_,cljs.core.reverse("a-long-string"));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"We have vectors",new cljs.core.Keyword(null,"content","content",15833224),"> Lisp is worth learning for the profound enlightenment experience you will have when you finally get it. - Eric Raymond\n     \n  **Vectors** (aka arrays), contains sequential elements and they have a faster access compared to lists.\n     \n  To create a vector you need to include the items into squared brackets `[]` without any separator.\n     \n  Create a vector of elements, like your favorite names for cats. ",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77134_SHARP_){
return cljs.core.vector_QMARK_(p1__77134_SHARP_);
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Def your variables",new cljs.core.Keyword(null,"content","content",15833224),"> Good programmers don't just write programs. They build a working vocabulary. - Guy Steele\n                                                                                     \n  **Global** variables are defined using `def`. Their value could be anything.\n     \n  Create a global variable called `foo` with a value. E.g. `(def foo \"bar\")`",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77135_SHARP_){
return (((p1__77135_SHARP_ instanceof sci.impl.vars.SciVar)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2("foo",cljs.core.str.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,"name","name",1843675177).cljs$core$IFn$_invoke$arity$1(p1__77135_SHARP_.meta)))));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Let it be local",new cljs.core.Keyword(null,"content","content",15833224),"> Lisp is so great not because of some magic quality visible only to devotees, but because it is simply the most powerful language available. - Paul Graham\n     \n  **Local** variables could be defined using `let`. They will be available only\n     inside the lexical context of the `let`. In the expression `(let [x 1] x)`\n     you can refer to x only inside the `body` part delimited by `()`.\n     \n  Create numeric variables and multiply them like `(let [a 2 b 3] (* a b))`.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77136_SHARP_){
return typeof p1__77136_SHARP_ === 'number';
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Maps are dictionaries",new cljs.core.Keyword(null,"content","content",15833224),"> Any fool can write code that a computer can understand. Good programmers write code that humans can understand. - Martin Fowler\n     \n  Maps are collections that map *keys* to *values*. They're wrapped into `{}`. \n     You can use everything as a key but Clojure programmers mostly use keywords.\n     \n  Create a map with a key `:country` and your country as a string. \n     Like `{:country \"Australia\"}`.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77137_SHARP_){
return ((cljs.core.map_QMARK_(p1__77137_SHARP_)) && (((cljs.core.contains_QMARK_(p1__77137_SHARP_,new cljs.core.Keyword(null,"country","country",312965309))) && (typeof new cljs.core.Keyword(null,"country","country",312965309).cljs$core$IFn$_invoke$arity$1(p1__77137_SHARP_) === 'string'))));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"First of list",new cljs.core.Keyword(null,"content","content",15833224),"Clojure offer some functions to extract content from the list. For example \n     `first` returns the first element.\n     \n  Type `(first '(\"alpha\" \"bravo\" \"charlie\"))` to get the first element.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77138_SHARP_){
return ((typeof p1__77138_SHARP_ === 'string') && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2("alpha",p1__77138_SHARP_)));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Range of N",new cljs.core.Keyword(null,"content","content",15833224),"Clojure function `range` create a list of number from 0 to `n`. \n     So `(range 5)` will return numbers from 0 to 5.\n     \n  Create a range from 0 to 99 or click on `(range 100)` :).",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77139_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__77139_SHARP_,cljs.core.range.cljs$core$IFn$_invoke$arity$1((100)));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Filter a list",new cljs.core.Keyword(null,"content","content",15833224),"We can apply functions to a list. For example using `filter` we can remove\n     all the elements that are not respecting our condition.\n     \n  Try to remove all the *even* numbers from 0 to 50. Psst, `(filter odd? (range 50))`",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77140_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__77140_SHARP_,cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.odd_QMARK_,cljs.core.range.cljs$core$IFn$_invoke$arity$1((50))));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Apply functions on lists",new cljs.core.Keyword(null,"content","content",15833224),"If we want a list of multiple of 11 less than 100 the process to find them\n     is to take each numbers from 1 to 9, multiply it by 10 and add it to the number, as\n     `5 * 10 + 5 = 55`. We can do the same thing with Clojure using `map`.\n\n  `map` simply apply a function to every element of a list. \n     \n  So use `(map (fn [n] (+ n (* n 10))) (range 1 10))` to do it.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77141_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__77141_SHARP_,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (n){
return (n + (n * (10)));
}),cljs.core.range.cljs$core$IFn$_invoke$arity$2((1),(10))));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"Inline functions",new cljs.core.Keyword(null,"content","content",15833224),"In the previous step, we wrote an inline function and passed it as argument\n      to `map`. I'm referring to `(fn [n] (+ n (* n 10)))`. This technique is usefull to create\n      functions as *generic utilities* and not write them for a specific use case.\n      \n  Now create a function that take `l` and `b` and returns the perimeter of a rectangle:\n      \n  `(fn [l b] (* (+ l b) 2))`.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77142_SHARP_){
return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(p1__77142_SHARP_,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(2),(3)], null)),(10));
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"REPL driven development",new cljs.core.Keyword(null,"content","content",15833224),"> The only way to learn a new programming language is by writing programs in it. - Kernighan and Ritchie\n     \n  You\u2019re currently solving a list of problems by typing and testing code into the REPL. \n     That\u2019s exactly what a Clojurist does! It's faster to test your code while typing more than compile and debug it later!\n     \n  But Clojure is much more than this. Type `(more)` to go to the last step.",new cljs.core.Keyword(null,"test","test",577538877),(function (p1__77143_SHARP_){
return p1__77143_SHARP_ === true;
})], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"title","title",636505583),"It's time to learn Clojure!",new cljs.core.Keyword(null,"content","content",15833224),"> In the beginner\u2019s mind there are many possibilities, but in the expert\u2019s there are few - Zen Mind, Beginner's Mind\n      \n  Clojure is **not** as difficult as it seems. Parenthesis, functions, immutable data structures and the REPL\n      will become your friends. Just keep a beginner's mind!\n      \n  Some good resources to start are [Clojure koans](http://clojurekoans.com/) and [4Clojure](https://4clojure.oxal.org/).\n\n  Ask the community for support, good luck!",new cljs.core.Keyword(null,"test","test",577538877),(function (){
return false === true;
})], null)], null);

//# sourceMappingURL=app.tutorial.js.map
