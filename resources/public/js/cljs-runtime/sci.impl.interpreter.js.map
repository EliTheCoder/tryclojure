{"version":3,"sources":["sci/impl/interpreter.cljc"],"mappings":";AAeA,iCAAA,jCAAMA,0EAAWC,IAAIC;AAArB,AAGE,GAAI,AAACC,qBAAKD;AACR,GAAI,6CAAA,AAAA,7CAACE,kGAAM,AAACC,gBAAMH;AAChB,IAAOI,QAAM,AAACC,eAAKL;UAAnB,NACOM;;AADP,AAEE,GAAI,AAACC,cAAIH;AACP,eACC,AAACC,eAAKD;eACN,iBAAAI,WAAWT;IAAXU,WAAe,AAACN,gBAAMC;AAAtB,AAAA,oIAAAI,SAAAC,qDAAAD,SAAAC,nMAACX,+DAAAA,kFAAAA;;;;;;AACFQ;;;;;AACJ,IACMI,YAAU,AAACC;IACXC,KAAG,yBAAA,0DAAA,2CAAA,IAAA,2CAAA,sDAAA,nOAACC,yEAAWH;IACfX,UAAI,yDAAA,4DAAA,6FAAA,8DAAA,hRAACe,qDAAMf,mJACUW,oJACQE;IAC7BG,WAAS,qEAAA,rEAACC,wDAAYjB,QAAIC;IAC1BiB,qBAAmB,AAACC,gBAAM,+CAAA,AAAAC,oBAAA,6FAAA,IAAA,pKAACC,+DAAQR,uFAAIF;IACvCW,WAAS,AAACC,qDAAaL;IACvBX,MAAI,EAAI,qBACoBiB,pBAAyBR,8CAC/C,iBAAAS,WAAWzB;IAAX0B,WAAe,AAAUV;AAAzB,AAAA,oIAAAS,SAAAC,qDAAAD,SAAAC,nMAAC3B,+DAAAA,kFAAAA;KACD,AAAC4B,wBAAU3B,QAAIsB,SAASN;AAZpC,AAaET;;;AACJ,IAAMI,YAAU,AAACC;IACXC,KAAG,yBAAA,0DAAA,2CAAA,IAAA,2CAAA,sDAAA,nOAACC,yEAAWH;IACfX,UAAI,yDAAA,4DAAA,6FAAA,8DAAA,hRAACe,qDAAMf,mJACUW,oJACQE;IAC7BG,WAAS,AAACC,wDAAYjB,QAAIC;IAC1BiB,qBAAmB,AAACC,gBAAM,+CAAA,AAAAC,oBAAA,6FAAA,IAAA,pKAACC,+DAAQR,uFAAIF;IACvCW,WAAS,AAACC,qDAAaL;IACvBX,MAAI,AAACoB,wBAAU3B,QAAIsB,SAASN;AARlC,AASET;;;AAEN,AAACqB,uBAAQC,+BAAsB9B;AAE/B,yCAAA,zCAAM+B,0FAAc9B,IAAI+B;AAAxB,AACE,AAAA,AAAAC,mCAAA,yEAAA,AAAAZ,zBAAqBc,yCAAiBA;;AAAtC,IAAA,AAAA,AACE,IAAMC,SAAO,AAACC,uFAA4B,AAACC,qFAA0BN;AAArE,AACE,UAAA,NAAOxB;;AAAP,AACE,IAAM+B,OAAK,AAACC,yDAAavC,IAAImC;AAA7B,AACE,GAAI,AAAAK,mCAAqBC,AAAA,gGAAMH;AAC7B/B;;AACA,IAAMA,UAAI,AAACR,+BAAUC,IAAIsC;AAAzB,AACE,eAAO/B;;;;;;UAPnB,AAAA,AAAA0B;;AASF,AAACL,uBAAQc,iCAAmBZ;AAI5B,AAAA,mCAAA,2CAAAa,9EAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,+DAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,+DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,iEAAA,jEAAMD,4EACFd;AADJ,AACO,wEAAA,jEAACgB,+DAAYhB;;;AADpB,CAAA,iEAAA,jEAAMc,4EAEFd,EAAEiB;AAFN,AAGG,IAAMC,WAAS,AAACC,mBAAUF;IACpBzC,MAAI,AAACuB,uCAAamB,SAASlB;AADjC,AAEExB;;;AALL,CAAA,2DAAA,3DAAMsC;;AAAN,AASA","names":["sci.impl.interpreter/eval-form","ctx","form","cljs.core/seq?","cljs.core._EQ_","cljs.core/first","exprs","cljs.core/rest","ret","cljs.core/seq","G__61941","G__61942","upper-sym","cljs.core.gensym","cb","cljs.core/volatile!","cljs.core.assoc","analyzed","sci.impl.analyzer.analyze","binding-array-size","cljs.core/count","cljs.core/deref","cljs.core.get_in","bindings","cljs.core.object_array","sci.impl.types/EvalForm","G__61944","G__61945","sci.impl.evaluator/eval","cljs.core/vreset!","sci.impl.utils/eval-form-state","sci.impl.interpreter/eval-string*","s","sci.impl.vars/push-thread-bindings","sci.impl.vars/pop-thread-bindings","sci.impl.vars/current-ns","reader","cljs.tools.reader.reader_types.indexing_push_back_reader","cljs.tools.reader.reader_types.string_push_back_reader","expr","sci.impl.parser.parse_next","cljs.core/keyword-identical?","sci.impl.parser/eof","sci.impl.utils/eval-string*","var_args","G__61952","sci.impl.interpreter/eval-string","js/Error","sci.impl.interpreter.eval_string","opts","init-ctx","sci.impl.opts/init"],"sourcesContent":["(ns sci.impl.interpreter\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-1])\n  (:require\n   [clojure.tools.reader.reader-types :as r]\n   [sci.impl.analyzer :as ana]\n   [sci.impl.evaluator :as eval]\n   [sci.impl.opts :as opts]\n   [sci.impl.parser :as p]\n   [sci.impl.types :as t]\n   [sci.impl.utils :as utils]\n   [sci.impl.vars :as vars]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn eval-form [ctx form]\n  ;; (.println System/err \"form\")\n  ;; (.println System/err form)\n  (if (seq? form)\n    (if (= 'do (first form))\n      (loop [exprs (rest form)\n             ret nil]\n        (if (seq exprs)\n          (recur\n           (rest exprs)\n           (eval-form ctx (first exprs)))\n          ret))\n      (let [;; take care of invocation array for let\n            upper-sym (gensym)\n            cb (volatile! {upper-sym {0 {:syms {}}}})\n            ctx (assoc ctx\n                       :parents [upper-sym 0]\n                       :closure-bindings cb)\n            analyzed (ana/analyze ctx form true)\n            binding-array-size (count (get-in @cb [upper-sym 0 :syms]))\n            bindings (object-array binding-array-size)\n            ret (if (instance? #?(:clj sci.impl.types.EvalForm\n                                  :cljs sci.impl.types/EvalForm) analyzed)\n                  (eval-form ctx (t/getVal analyzed))\n                  (eval/eval ctx bindings analyzed))]\n        ret))\n    (let [upper-sym (gensym)\n          cb (volatile! {upper-sym {0 {:syms {}}}})\n          ctx (assoc ctx\n                     :parents [upper-sym 0]\n                     :closure-bindings cb)\n          analyzed (ana/analyze ctx form)\n          binding-array-size (count (get-in @cb [upper-sym 0 :syms]))\n          bindings (object-array binding-array-size)\n          ret (eval/eval ctx bindings analyzed)]\n      ret)))\n\n(vreset! utils/eval-form-state eval-form)\n\n(defn eval-string* [ctx s]\n  (vars/with-bindings {vars/current-ns @vars/current-ns}\n    (let [reader (r/indexing-push-back-reader (r/string-push-back-reader s))]\n      (loop [ret nil]\n        (let [expr (p/parse-next ctx reader)]\n          (if (utils/kw-identical? p/eof expr)\n            ret\n            (let [ret (eval-form ctx expr)]\n              (recur ret))))))))\n\n(vreset! utils/eval-string* eval-string*)\n\n;;;; Called from public API\n\n(defn eval-string\n  ([s] (eval-string s nil))\n  ([s opts]\n   (let [init-ctx (opts/init opts)\n         ret (eval-string* init-ctx s)]\n     ret)))\n\n;;;; Scratch\n\n(comment\n  (eval-string \"((fn f [x] (if (< x 3) (recur (inc x)) x)) 0)\")\n  )\n"]}