{"version":3,"sources":["app/tutorial.cljs"],"mappings":";AAKA;;;wBAAA,oFAAA,2CAAA,sDAAA,gBAAA,yDAAA,uUAAA,oDAAA,WAAAA,5pBAAKiB;AAAL,AAYW,gGAAA,zFAACC,6CAAE,0BAAAlB,1BAACmB;WAZf,2CAAA,sDAAA,oBAAA,yDAAA,sdAAA,oDAAA,WAAAlB;AAAA,AAwBW,oDAAAA,iBAAA,AAAA,9DAACiB;WAxBZ,2CAAA,sDAAA,gBAAA,yDAAA,+OAAA,oDAAA,WAAAhB;AAAA,AAgCW,cAAAA;WAhCX,2CAAA,sDAAA,wBAAA,yDAAA,maAAA,oDAAA,WAAAC;AAAA,AA2CW,qDAAA,5CAAK,qBAAAA,rBAACiB,8CAAQ,0BAAAjB,iBAAA,3CAACkB,gHAAwB,OAAS,AAAA,6FAAAlB;WA3C3D,2CAAA,sDAAA,wBAAA,yDAAA,sdAAA,oDAAA,WAAAC;AAAA,AAwDW,oDAAAA,iBAAA,9DAACc;WAxDZ,2CAAA,sDAAA,4BAAA,yDAAA,ubAAA,oDAAA,WAAAb;AAAA,AAqEW,iCAAAA,iBAAA,3CAACgB;WArEZ,2CAAA,sDAAA,2BAAA,yDAAA,idAAA,oDAAA,WAAAf;AAAA,AAgFW,oDAAAA,7CAACY,8DAAI,kBAAA,lBAACI;WAhFjB,2CAAA,sDAAA,kBAAA,yDAAA,qaAAA,oDAAA,WAAAf;AAAA,AA2FW,+BAAAA,xBAACgB;WA3FZ,2CAAA,sDAAA,qBAAA,yDAAA,4VAAA,oDAAA,WAAAf;AAAA,AAoGW,SAAK,CAAAA,4BAAWgB,2BAAU,6CAAA,7CAACN,mDAAQ,4CAAA,AAAA,mFAAI,AAAAV;WApGlD,2CAAA,sDAAA,kBAAA,yDAAA,oeAAA,oDAAA,WAAAC;AAAA,AA+GW,cAAAA;WA/GX,2CAAA,sDAAA,wBAAA,yDAAA,kaAAA,oDAAA,WAAAC;AAAA,AA0HW,qDAAA,5CAAK,qBAAAA,rBAACU,8CAAQ,0BAAAV,iBAAA,3CAACW,2GAAsB,OAAS,AAAA,wFAAAX;WA1HzD,2CAAA,sDAAA,gBAAA,yDAAA,6MAAA,oDAAA,WAAAC;AAAA,AAkIW,SAAK,OAAAA,mCAAY,6CAAA,QAAAA,rDAACO;WAlI7B,2CAAA,sDAAA,aAAA,yDAAA,6LAAA,oDAAA,WAAAN;AAAA,AA0IW,oDAAAA,7CAACM,8DAAI,8CAAA,9CAACO;WA1IjB,2CAAA,sDAAA,gBAAA,yDAAA,yOAAA,oDAAA,WAAAZ;AAAA,AAkJW,oDAAAA,7CAACK,8DAAI,AAACQ,+CAAOC,qBAAK,8CAAA,9CAACF;WAlJ9B,2CAAA,sDAAA,2BAAA,yDAAA,2XAAA,oDAAA,WAAAX;AAAA,AA6JW,oDAAAA,7CAACI,8DAAI,AAACU,4CAAI,WAAKC;AAAL,AAAQ,QAAGA,IAAE,KAAA,JAAGA;GAAQ,8CAAA,IAAA,lDAACJ;WA7J9C,2CAAA,sDAAA,mBAAA,yDAAA,2YAAA,oDAAA,WAAAV;AAAA,AAwKY,uNAAA,hNAACG,6CAAE,8CAAAH,iBAAA,mFAAA,IAAA,tJAACe;WAxKhB,2CAAA,sDAAA,0BAAA,yDAAA,uaAAA,oDAAA,WAAAd;AAAA,AAkLW,OAAAA;WAlLX,2CAAA,sDAAA,8BAAA,yDAAA,ueAAA,oDAAA;AAAA,AA6LY,OAAA","names":["p1__77127#","p1__77128#","p1__77129#","p1__77130#","p1__77131#","p1__77132#","p1__77133#","p1__77134#","p1__77135#","p1__77136#","p1__77137#","p1__77138#","p1__77139#","p1__77140#","p1__77141#","p1__77142#","p1__77143#","app.tutorial/tutorial","cljs.core._EQ_","clojure.string/lower-case","cljs.core/map?","cljs.core/contains?","cljs.core/reverse","cljs.core/vector?","sci.impl.vars/SciVar","cljs.core.range","cljs.core.filter","cljs.core/odd?","cljs.core.map","n","cljs.core.apply"],"sourcesContent":["(ns app.tutorial\n  (:require\n   [clojure.string :as string]\n   [sci.impl.vars :refer [SciVar]]))\n\n(def tutorial\n  \"Collection of map steps.\"\n  [;; Strings\n   {:title\n    \"Hello string!\"\n    :content\n    \"> Learn the principle, abide by the principle, and dissolve the principle. - Bruce Lee\n     \n  Let's start with the basic. Clojure offers the most common data types, like integers,\n     boolean and strings. Strings are surrounded by `\\\"`.\n    \n  Try creating a string saying *hello* to the *world*, as `\\\"Hello World\\\"`\"\n    :test #(= (string/lower-case %) \"hello world\")}\n   ;; Lists\n   {:title \"Embrace the lists\"\n    :content\n    \"> Lisp is the greatest single programming language ever designed - Alan Kay\n    \n  Lisp stands for *LISt Processing* and its peculiarity is that code is written in [lists](https://en.wikipedia.org/wiki/S-expression). Clojure is a Lisp dialect so it uses a similar syntax.\n\n  A list is a collection of items as `(1 2 3)`. In Clojure you can\n     create lists using `list` or prepending `'`.\n\n  Create a list of elements for example `(list 1 2 3)` or `'(1 2 3)`.\"\n    :test #(= % '(1 2 3))}\n   ;; Math\n   {:title \"Math is (fun)\"\n    :content\n    \"In Clojure mathematical operators are like normal functions. \n     As you already know, you have to include them in parenthesis `(...)`.\n  \n  So instead of `4 + 2` you will do `(+ 4 2)`. Try to type a numerical operation with `+-/*`.\"\n    :test #(number? %)}\n   ;; Functions\n   {:title \"Clojure is functional\"\n    :content\n    \"> Lisp is functional. And the future is looking very functional to me. - Robert C. Martin\n  \n  The first argument of a list needs to be a **function**. The *rest*, \n     are the arguments to that function. In the expression `(not true)`,\n     *not* is the negation function and *true* is the argument. \n     \n  Try to use the function `(my-name)` followed by your name as a \\\"string\\\", as `(my-name \\\"Elia\\\")`.\"\n    :test #(and (map? %) (contains? % :user-name) (string? (:user-name %)))}\n   ;; Keywords\n   {:title \"Don't forget the keys\"\n    :content\n    \"> These days, the problem isn't how to innovate; it's how to get society to adopt the good ideas that already exist. - Douglas Engelbart\n     \n  Hi there, **[[user-name]]**! Nice to meet you.\n    \n  In the REPL you are getting back the evaluation of the expression that you typed.\n    As you can see, `:user-name` is in a special form; it's called a *keyword*.\n    You have to prepend `:` to a word to create one. \n     \n  Use the keyword `:next` to continue.\"\n    :test #(= % :next)}\n   ;; Exercise - 01\n   {:title \"A function for everything\"\n    :content\n    \"Let's tweak our interface!\n     \n  You already know how to invoke functions, how to use keywords and strings.\n     What if I tell you that you can change the prompt?\n\n  You can call functions with keywords parameters, as `(create-dog :name \\\"Zeus\\\" :breed \\\"Beagle\\\")`\n     \n  Use the function `(set-prompt)` and set a color. It accepts optionally `:color` and `:text` as strings. \n     On click on `(set-prompt :color \\\"red\\\")`\"\n    :test #(contains? % :prompt-color)}\n   ;; \n   {:title \"Functional practicioner!\"\n    :content\n    \"Congratulations, you have called a function and changed the state of the application! \n     And the entire command was\u2026 a list!\n                                                                                     \n  Clojure offers multiple functions to work with lists, as `reverse`. It reverse a collection\n     so if you pass a string will use it as a collection of characters.\n     \n  Type `(reverse \\\"a-long-string\\\")` to advance at the next step.\"\n    :test #(= % (reverse \"a-long-string\"))}\n   ;; Vectors\n   {:title \"We have vectors\"\n    :content\n    \"> Lisp is worth learning for the profound enlightenment experience you will have when you finally get it. - Eric Raymond\n     \n  **Vectors** (aka arrays), contains sequential elements and they have a faster access compared to lists.\n     \n  To create a vector you need to include the items into squared brackets `[]` without any separator.\n     \n  Create a vector of elements, like your favorite names for cats. \"\n    :test #(vector? %)}\n   ;; Variables\n   {:title \"Def your variables\"\n    :content\n    \"> Good programmers don't just write programs. They build a working vocabulary. - Guy Steele\n                                                                                     \n  **Global** variables are defined using `def`. Their value could be anything.\n     \n  Create a global variable called `foo` with a value. E.g. `(def foo \\\"bar\\\")`\"\n    :test #(and (instance? SciVar %) (= \"foo\" (-> (.-meta %) :name str)))}\n   ;; Let\n   {:title \"Let it be local\"\n    :content\n    \"> Lisp is so great not because of some magic quality visible only to devotees, but because it is simply the most powerful language available. - Paul Graham\n     \n  **Local** variables could be defined using `let`. They will be available only\n     inside the lexical context of the `let`. In the expression `(let [x 1] x)`\n     you can refer to x only inside the `body` part delimited by `()`.\n     \n  Create numeric variables and multiply them like `(let [a 2 b 3] (* a b))`.\"\n    :test #(number? %)}\n   ;; Maps\n   {:title \"Maps are dictionaries\"\n    :content\n    \"> Any fool can write code that a computer can understand. Good programmers write code that humans can understand. - Martin Fowler\n     \n  Maps are collections that map *keys* to *values*. They're wrapped into `{}`. \n     You can use everything as a key but Clojure programmers mostly use keywords.\n     \n  Create a map with a key `:country` and your country as a string. \n     Like `{:country \\\"Australia\\\"}`.\"\n    :test #(and (map? %) (contains? % :country) (string? (:country %)))}\n   ;; F-list\n   {:title \"First of list\"\n    :content\n    \"Clojure offer some functions to extract content from the list. For example \n     `first` returns the first element.\n     \n  Type `(first '(\\\"alpha\\\" \\\"bravo\\\" \\\"charlie\\\"))` to get the first element.\"\n    :test #(and (string? %) (= \"alpha\" %))}\n   ;; Range\n   {:title \"Range of N\"\n    :content\n    \"Clojure function `range` create a list of number from 0 to `n`. \n     So `(range 5)` will return numbers from 0 to 5.\n     \n  Create a range from 0 to 99 or click on `(range 100)` :).\"\n    :test #(= % (range 100))}\n   ;; Filter\n   {:title \"Filter a list\"\n    :content\n    \"We can apply functions to a list. For example using `filter` we can remove\n     all the elements that are not respecting our condition.\n     \n  Try to remove all the *even* numbers from 0 to 50. Psst, `(filter odd? (range 50))`\"\n    :test #(= % (filter odd? (range 50)))}\n   ;; Map\n   {:title \"Apply functions on lists\"\n    :content\n    \"If we want a list of multiple of 11 less than 100 the process to find them\n     is to take each numbers from 1 to 9, multiply it by 10 and add it to the number, as\n     `5 * 10 + 5 = 55`. We can do the same thing with Clojure using `map`.\n\n  `map` simply apply a function to every element of a list. \n     \n  So use `(map (fn [n] (+ n (* n 10))) (range 1 10))` to do it.\"\n    :test #(= % (map (fn [n] (+ n (* n 10))) (range 1 10)))}\n    ;; Inline functions\n    {:title \"Inline functions\"\n     :content\n     \"In the previous step, we wrote an inline function and passed it as argument\n      to `map`. I'm referring to `(fn [n] (+ n (* n 10)))`. This technique is usefull to create\n      functions as *generic utilities* and not write them for a specific use case.\n      \n  Now create a function that take `l` and `b` and returns the perimeter of a rectangle:\n      \n  `(fn [l b] (* (+ l b) 2))`.\"\n     :test #(= (apply % [2 3]) 10)}\n   ;; REPL\n   {:title \"REPL driven development\"\n    :content\n    \"> The only way to learn a new programming language is by writing programs in it. - Kernighan and Ritchie\n     \n  You\u2019re currently solving a list of problems by typing and testing code into the REPL. \n     That\u2019s exactly what a Clojurist does! It's faster to test your code while typing more than compile and debug it later!\n     \n  But Clojure is much more than this. Type `(more)` to go to the last step.\"\n    :test #(true? %)}\n    {:title \"It's time to learn Clojure!\"\n     :content\n     \"> In the beginner\u2019s mind there are many possibilities, but in the expert\u2019s there are few - Zen Mind, Beginner's Mind\n      \n  Clojure is **not** as difficult as it seems. Parenthesis, functions, immutable data structures and the REPL\n      will become your friends. Just keep a beginner's mind!\n      \n  Some good resources to start are [Clojure koans](http://clojurekoans.com/) and [4Clojure](https://4clojure.oxal.org/).\n\n  Ask the community for support, good luck!\"\n     :test #(true? false)}])\n"]}